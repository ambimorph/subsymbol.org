<html><body><div class="document" id="hacker-school-wednesday-june-25th-2014">   <p>On Wednesday, I blasted through some more Protagonist work, and started sprouting the seeds of a few more projects.  Most importantly, I made further progress on thinking about how to make further progress.</p><div class="section" id="more-goals-work"><h3>More Goals Work</h3><p>At Stacey's Goals Workshop, I submitted the following fill-in-the-blanks exercise:</p><blockquote><p>"This batch I am working on <strong>balancing learning a new language (Factor) and getting some concrete projects completed,</strong>because <strong>I want to feel the creativity of doing something new, but I also want develop my strengths in making real things.</strong></p><p>So far I've tried <strong>combining those by doing a project idea in Factor</strong>and the result was <strong>frustration in both areas.</strong></p><p>Therefore, my next steps are <strong>to develop the project in a language I know (Python), and find other ways to learn Factor."</strong></p></blockquote><p>We went through a process of understanding the goals behind the goals, and other clarifications. I gained two important insights into my current problem.</p><ul><li><p class="first">The first one happened when I was trying to explain why I want to learn Factor. I was able to notice that although Factor has some particularly nice typing and polymorphism properties and constructs that I ultimately want to use, the biggest reason I want to learn it, and the hardest part about it, is the fact that it is a stack-based, concatenative language, which is a new and interesting paradigm for me. Answering this questioned reopened the decision point of which such language to learn, which had become the base assumption.</p><p>The central problem that I am having with learning Factor in particular is that there are no teaching resources available, at least that I have found, that can take the learner in a guided way through progressively powerful idioms. If it is the case that there are such resources for Forth, which seems likely, then it might be a good strategy to learn Forth first, and then I will be able to transfer that skill to using Factor for its higher abstractions. A few people suggested this to me before it sank in as a Good Idea. One Hacker Schooler has even offered to pair with me on writing a Forth interpreter.</p></li></ul><p>This brings me to my other insight.</p><ul><li><p class="first">The higher problem that I have been struggling with is how to balance my conflicting goals. I have tried tying them together, and it seemed suboptimal.</p><p><em>(I had a similar problem when I tried to learn Haskell through Project Euler problems â€” I did much better Haskell learning going through part of a course designed to introduce the language in graduated steps than to try to figure out what I need as needed. The strategy of doing projects in a language to learn it seems to be appropriate only after a certain base level of competence.)</em></p><p>If I do two things at once that are not tied, then I have to choose how to allocate time, and when to switch. A colleague who was listening to my problem suggested that I make switching be goal based, rather than time based. That is, I could work on Protagonist until I reach some minimal satisfying feature set, and then do something goal-based for learning a concatenative language, and then if I want to do another round of features on Protagonist I can.  Or I could do something else. This seems quite sane.</p></li></ul></div><div class="section" id="hacker-school-mothers"><h3>Hacker School Mothers</h3><p>I got to chat with two other women yesterday who came to Hacker School leaving children behind, and who are facing or have faced the challenges of building a post-motherhood career. This helped me process some feelings of guilt and fear that have been lurking.</p></div><div class="section" id="check-in"><h3>Check-in</h3><div class="section" id="plan"><h4>Plan</h4><ul class="simple"><li>Protagonist: write out some specs, and continue implementing.</li><li>Work with another Schooler on machine learning algorithms.</li><li>Attend Stacey Sern's Goal Setting workshop.</li></ul></div><div class="section" id="actual"><h4>Actual</h4><ul class="simple"><li>Protagonist:<ul><li>Updated the README to reflect what I had in mind so far.</li><li>Implemented several functions and tests.</li><li>Figured out the algorithm I want to use for parsing boolean queries.</li><li>Worried a bit about the problem of the file_id not being human readable.</li></ul></li><li>Machine Learning:<ul><li>Talked about how to get started.  We wanted to get some real data, and then apply some machine learning to cluster or organise it.<ul><li>So we started learning how to use the Python <cite>requests</cite> and <cite>b24</cite> (BeautifulSoup) modules.</li><li>I pitched one of my favourite algorithms that I've been wanting to implement for a long time, which is <em>LDA</em> (<a class="reference external" href="http://en.wikipedia.org/wiki/Latent_Dirichlet_allocation">Latent Dirichlet Allocation</a>), to model the topics in a collection of websites. We could then cluster the documents by topic distribution.</li></ul></li></ul></li><li>Goal Setting<ul><li>As detailed above, attending Stacey's workshop helped me to tease out a few more things about my current directions, which was very helpful.</li></ul></li></ul></div></div></div></body></html>