<html><body><div class="document" id="hacker-school-monday-june-16th-2014">   <p>The days are passing way too quickly, and I'm glad I have been logging, because it helps keep me grounded.  Yes, I see some of my favourite project ideas slipping away, but I also see some progress, and that is heartening. Also, it is useful to re-evaluate early and often.</p><p>I have started to have to say "no" to things more, which is always hard, but it's realistic. Many of the conventions of life hide choices under assumptions.  You go to high school, because that's <em>the</em> choice.  You take the classes they offer, and within each class you do the assignments chosen for you. When I got to university the first time, I was blown away by how much math existed that my teachers had never alluded to, and that I had never even thought to look for.  It was endless. Yet even at university, even at grad school, many of the choices can be delegated, and then perhaps you take a job in your field.  This is the "track" I was drawn to, and partly born to.</p><p>So now I am having to say "no" to way more things I can say "yes" to, and that's great, because on the one hand, almost all of the choices have advantages, so it's hard to lose, and on the other hand it is training me to choose, and that is a powerful skill.</p><div class="section" id="plan"><h3>Plan</h3><ul class="simple"><li>Learning Haskell:<ul><li>Start <a class="reference external" href="http://www.seas.upenn.edu/~cis194/">Yorgey's Haskell course</a>.</li></ul></li><li><a class="reference external" href="https://github.com/ambimorph/protagonist">Protagonist</a>:<ul><li>Restart in Factor.<ul><li>Write the first, skeletal test</li><li>Write a test for <cite>add_tag</cite>.  This will involve figuring out how to parse the command line from Factor.</li></ul></li></ul></li><li>Contributing to Tahoe-LAFS design:<ul><li>Get some clarification on a question I have about the functionality.</li></ul></li><li>Light Reading:<ul><li><a class="reference external" href="http://lambda.jimpryor.net/">What Philosophers and Linguists Can Learn From Theoretical Computer Science But Didn't Know To Ask</a>, Week 1.</li></ul></li></ul></div><div class="section" id="actual"><h3>Actual</h3><div class="section" id="haskell"><h4>Haskell:</h4><blockquote><ul class="simple"><li>Read Lecture 1 and did Homework 1, exercise 1.</li><li>Cleared up some confusion I was having about ghci, with the help of Hacker Schoolers.</li></ul></blockquote></div><div class="section" id="factor"><h4>Factor:</h4><blockquote><ul><li><p class="first">Figured out how to use Factor code outside of the Factor code tree, using the environment variable FACTOR_ROOTS, and how to set up the vocabularies so they will be found.</p><p>"if your vocabulary name is a.b.c then the expected location from FACTOR_ROOTS is a/b/c/c.factor and and a/b/c/c-tests.factor with with IN: a.b.c"</p></li><li><p class="first">Started writing a minimal test, and had trouble figuring out some basic idioms.</p></li><li><p class="first">Skimmed through Slava Pestov's Google Tech talk again.</p><ul><li><p class="first">Slava compares the way polymorphism is handled in OOP, functional languages, and Factor:</p><ul><li><p class="first">OOP passes messages to classes via methods.  So for example, there may be a rectangle class and a circle class, and they each implement an area method.</p><p>Disadvantage: hard to define new operations; have to add to every class, and you may not have access.</p></li><li><p class="first">Functional languages have algebraic data types: when you define the operation, you give a definition for each data subtype that matches.</p><p>Disadvantage: When there is a new type, you have to extend every operation.</p></li><li><p class="first">Factor borrows from Common Lisp in decoupling:</p><p>Generic words have behaviour that depends on the type that is on the stack.</p><pre class="code factor literal-block"><br>E.g. <span class="keyword">GENERIC:</span> <span class="name function">area</span><span class="name builtin"> </span><span class="name function">(</span> <span class="name variable">shape</span> <span class="name function">--</span> <span class="name variable">n</span> <span class="name function">)</span><br></pre><p>This then allows any method to be independently defined:</p><pre class="code factor literal-block"><br><span class="keyword">M:</span> <span class="name class">rectangle</span> <span class="name function">area</span><span class="name builtin"> </span>[<span class="name builtin"> </span>width&gt;&gt;<span class="name builtin"> </span>]<span class="name builtin"> </span>[<span class="name builtin"> </span>height&gt;&gt;<span class="name builtin"> </span>]<span class="name builtin"> bi </span><span class="operator">* </span><span class="keyword">;<br></span><span class="comment">! Recall that the bi combinator cleaves the two preceding quotations, so that they can both apply to the previous object.</span><span class="name builtin"><br></span><span class="comment">! width&gt;&gt; and height&gt;&gt; are thus applied to the rectangle that area has grabbed from the stack.</span><br><br><span class="keyword">M:</span> <span class="name class">circle</span> <span class="name function">area</span><span class="name builtin"> </span>radius&gt;&gt;<span class="name builtin"> sq </span>pi<span class="name builtin"> </span><span class="operator">* </span><span class="keyword">;</span><br></pre><p>Then you can define a type <cite>MIXIN</cite> which alllows you to declare new types as instances of another class.</p><pre class="code factor literal-block"><br><span class="keyword">TUPLE:</span> <span class="name class">parallelogram</span> <span class="name variable">...</span> <span class="keyword">;<br>INSTANCE:</span><span class="name builtin"> </span>parallelogram<span class="name builtin"> </span>shape<br><span class="keyword">M:</span> <span class="name class">parallelogram</span> <span class="name function">area</span><span class="name builtin"> </span>...<span class="name builtin"> </span><span class="keyword">;</span><br></pre></li></ul></li><li><p class="first">I created an object using <cite>TUPLE</cite> with a default value to use in my test.</p></li></ul></li></ul></blockquote></div><div class="section" id="tahoe-lafs"><h4>Tahoe-LAFS:</h4><blockquote>I got clarification on the functionality of the backup command and figured out why I was confused about it.  Now I am in a position to continue writing my proposal draft.</blockquote></div><div class="section" id="reading"><h4>Reading:</h4><p>I did not get to the linguistics, but I read another post by someone excited about concatenative languages: <a class="reference external" href="http://www.codecommit.com/blog/cat/the-joy-of-concatenative-languages-part-1">Daniel Spiewak's The Joy of Concatenative Languages Part 1</a>.</p></div></div><div class="section" id="pseudo-random-thoughts"><h3>Pseudo-Random Thoughts</h3><p>I keep thinking about the connections between type systems, proofs, and natural language parsing. The Haskell lecture said "Programs with type errors will not even compile, much less run."  I have been developing an analogy to natural language where compile :: parse, and run :: create a meaning structure. I hope to develop that more over the coming weeks.</p></div></div></body></html>