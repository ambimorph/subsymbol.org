<html><body><p>Sometimes unit tests take more than a few seconds to run, especially if they involve training a small test corpus in some way or other.  This can be dangerous for my focus.  "I'll just check my email while I'm waiting for this test to complete." are famous last words that can lead to a slow development cycle.  See <a href="http://xkcd.com/303/">compiling</a>. </p><p>So, I started queuing a sound file to play after each test finished.  This way I would be alerted immediately, rather than relying on polling. </p><p>Recently <a href="http://zooko.com">Zooko</a> helped me improve this system by adding the feature of switching the file to play based on the test results. </p><p>Currently, I have the following alias in my .bash_aliases file: </p><pre><code><br>alias testbell='X=$? ;  if [ $X = 0 ] ; then mplayer -really-quiet -volume 50 ~/<a href="https://github.com/edse/puzzle/blob/master/audio/51710__bristolstories__u-chimes3.mp3?raw=true">chimes3.mp3</a> ; <br>else mplayer -really-quiet ~/<a href="http://soundjax.com/reddo/51294%5EWINDGONG.mp3">gong.mp3</a>  ; fi'<br></code></pre> The -really-quiet flag is about verbosity, not volume, and the -volume 50 is just because my chimes file is much louder than my gong file. <br><br><p>So today, for example, I've been running: </p><pre><code><br>time python -m unittest code.error_insertion.test.test_RealWordErrorChannel.RealWordErrorChannelTest ;<br> testbell<br></code></pre><br><p>A friend told me it sounds like there is a fairy somewhere intermittently trying to escape.</p></body></html>